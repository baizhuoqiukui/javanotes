# Java基础

## 说一下Object类中都有哪些方法？

### toString

定义一个对象字符串的表现形式，默认是 **类全路径名+@+对象的哈希码**，可以重写

### clone

返回一个对象的副本（效率高比new快，原型模式），使用时对象类要实现Cloneable接口

**浅克隆**：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址

**深克隆**：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。

### finalized 

 一旦垃圾回收器准备释放对象所占的内存空间, 如果对象覆盖了finalize()并且函数体内不能是空的, 就会首先调用对象的finalize(),  然后在下一次垃圾回收动作发生的时候真正收回对象所占的空间.

可以在该方法内进行添加引用，进行对象的自救

## JDK1.8新特性了解过吗？

* Lambda表达式

* 函数式接口 函数式编程
* 方法引用和构造器调用
* Stream API
* 接口中的默认方法和静态方法
* 新时间日期API

## JDK1.8 Stream，详述一下stream的并行操作原理？stream并行的线程池是从哪里来的？

它是对容器对象功能的增强，它专注于对容器对象进行各种非常便利、高效的聚合操作或者大批量数据操作。

tream API借助于同样新出现的Lambda表达式，极大的提高编程效率和程序可读性。同时，它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用fork/join并行方式来拆分任务和加速处理过程。所以说，Java8中首次出现的 java.util.stream是一个函数式语言+多核时代综合影响的产物。

Stream有如下三个操作步骤：

一、创建Stream：从一个数据源，如集合、数组中获取流。

二、中间操作：一个操作的中间链，对数据源的数据进行操作。

三、终止操作：一个终止操作，执行中间操作链，并产生结果。

stream并行原理: 其实本质上就是在ForkJoin上进行了一层封装，将Stream 不断尝试分解成更小的split，然后使用fork/join 框架分而治之, parallize使用了默认的ForkJoinPool.common 默认的一个静态线程池.

## 什么是ForkJoin框架 适用场景

虽然目前处理器核心数已经发展到很大数目，但是按任务并发处理并不能完全充分的利用处理器资源，因为一般的应用程序没有那么多的并发处理任务。基于这种现状，考虑把一个任务拆分成多个单元，每个单元分别得到执行，最后合并每个单元的结果。 

Fork/Join框架是JAVA7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干小任务，最终汇总每个小任务结果得到大任务结果的框架。 

**2.工作窃取算法（work-stealing）** 

一个大任务拆分成多个小任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列中，并且每个队列都有单独的线程来执行队列里的任务，线程和队列一一对应。 

但是会出现这样一种情况：A线程处理完了自己队列的任务，B线程的队列里还有很多任务要处理。 

A是一个很热情的线程，想过去帮忙，但是如果两个线程访问同一个队列，会产生竞争，所以A想了一个办法，从双端队列的尾部拿任务执行。而B线程永远是从双端队列的头部拿任务执行。

注意：线程池中的每个线程都有自己的工作队列（PS，这一点和ThreadPoolExecutor不同，ThreadPoolExecutor是所有线程公用一个工作队列，所有线程都从这个工作队列中取任务），当自己队列中的任务都完成以后，会从其它线程的工作队列中偷一个任务执行，这样可以充分利用资源。 

 

**工作窃取算法的优点：** 

​     利用了线程进行并行计算，减少了线程间的竞争。 

**工作窃取算法的缺点：** 

​     任务争夺问题

## equals()和==区别。为什么重写equal要重写hashcode？

== 是运算符  equals来自于Object类定义的一个方法

== 可以用于基本数据类型和引用类型

equals只能用于引用类型

 

== 两端如果是基本数据类型,就是判断值是否相同

equals如果不重写,其实就是 == 

 

重写equals可以让我们自己定义判断两个对象是否相同的条件

Object中定义的hashcode方法生成的哈希码能保证同一个类的对象的哈希码一定是不同的

当equals 返回为true,我们在逻辑上可以认为是同一个对象,但是查看哈希码,发现哈希码不同,和equals方法的返回结果违背

 

Object中定义的hashcode方法生成的哈希码跟对象的本身属性值是无关的

**重写hashcode之后,我们可以自定义哈希码的生成规则,可以通过对象的属性值计算出哈希码，方便查找**

 

HashMap中,借助equals和hashcode方法来完成数据的存储

 

将根据对象的内容查询转换为根据索引查询