# 事务隔离级别

https://cloud.tencent.com/developer/article/1450773

## 脏读

### 事务读到未提交的数据。

​		A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。

![dirtyRead](https://github.com/baizhuoqiukui/javanotes/tree/master/highPerformanceMySQL/事务隔离级别.assets/dirtyRead.jpeg)

## 

## 不可重复读

### **前后多次读取，数据内容不一致**

​		事务A在执行读取操作，事务A比较大，第一次读取后经过很长时间再进行读取。而在事务A第一次读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，称为不可重复读。

![noRepeat](https://github.com/baizhuoqiukui/javanotes/highPerformanceMySQL/事务隔离级别.assets/noRepeat.png)



## **幻读（前后多次读取，数据总量不一致）**

### 事务在读取某个范围的记录时，另一个事务又在这个范围插入了一段记录，然后事务再次读取。

事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，称为幻读。

![huanRead](https://github.com/baizhuoqiukui/javanotes/highPerformanceMySQL/事务隔离级别.assets/huanRead.png)



## 不可重复读和幻读的区别

幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是**同一个数据项**，而幻读针对的是**一批数据整体**（比如数据的个数）。

(1) 不可重复读是读取了其他事务更改的数据，**针对update操作**

解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。

(2) 幻读是读取了其他事务新增的数据，**针对insert和delete操作**

解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。



## 不可重复读和脏读的区别

脏读是事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。



## 事务隔离级别

**1.Read uncommitted **

**2.Read committed**

**Oracle、SQL Server的默认隔离级别**

**3.Repeatable read**

**Mysql的默认隔离级别**

**4.Serializable**

![j0gc9gmx2e](https://github.com/baizhuoqiukui/javanotes/highPerformanceMySQL/事务隔离级别.assets/j0gc9gmx2e.png)
