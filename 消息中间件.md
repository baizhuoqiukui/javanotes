# 消息中间件

# 什么是JMS MQ

全称：Java MessageService 中文：Java 消息服务。 

JMS 是 Java 的一套 API 标准，指的是利用高效可靠的消息传递机制进行**平台无关的数据交流**，并基于数据通信来进行分布式系统的集成。

“消息”是在两台计算机间传送的数据单位。消息可以非常简单，例如只包含文本字符串； 也可以更复杂，可能包含嵌入对象。 消息被发送到队列中。

“消息队列”是在消息的传输过程中**保存消息的容器**。消息队列管理器,再将消息从它的源，中继到它的目标时充当中间人。

队列的主要目的是提供路由并保证消 息的传递；如果发送消息时接收者不可用，消息队列会保留消息，直到可以成功地传递它。

消息队列的主要特点是**异步处理**，主要目的是**减少请求响应时间和解耦**。所以主要的使用场景就是**将比较耗时而且不需要即时（同步）返回结果的操作作为消息放入消息队列**。

同 时由于使用了消息队列，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系， 也不需要受对方的影响，即解耦和。如: 跨系统的异步通信，所有需要异步交互的地方都可以使用消息队列。就像我们除了打电 话（同步）以外，还需要发短信，发电子邮件（异步）的通讯方式。 多个应用之间的耦合，由于**消息是平台无关和语言无关**的，而且语义上也不再是函数调 用，因此更适合作为多个应用之间的松耦合的接口。基于消息队列的耦合，**不需要发送方和 接收方同时在线**。

应用内的同步变异步，比如订单处理，就可以由**前端应用将订单信息放到队列**，**后端应 用从队列里依次获得消息处理**，高峰时的**大量订单可以积压在队列里慢慢处理掉**。由于同步 通常意味着阻塞，而大量线程的阻塞会降低计算机的性能。

**消息驱动的架构（EDA），系统分解为消息队列，和消息制造者和消息消费者，一个处理流程可以根据需要拆成多个阶段（Stage） ，阶段之间用队列连接起来，前一个阶段处理的结果放入队列，后一个阶段从队列中获取消息继续处理。** 应用需要更灵活的耦合方式，如发布订阅，比如可以指定路由规则。 跨局域网，甚至跨城市的通讯，比如北京机房与广州机房的应用程序的通信。

# ActiveMQ

## 快速上手

官网：https://activemq.apache.org/

执行activemq.bat

启动后登录http://127.0.0.1:8161/ admin admin

![image-20210519164946231](消息中间件.assets/image-20210519164946231.png)

Manage ActiveMQ broker 就是启动得服务器，点击

![image-20210519165324080](消息中间件.assets/image-20210519165324080.png)

场景：

 ![image-20210519170820844](消息中间件.assets/image-20210519170820844.png)

程序需要执行三步，总耗时415毫秒，整个过程是同步执行的

![image-20210519172251823](消息中间件.assets/image-20210519172251823.png)

使用多线程异步，需要取2、3执行时间的最大值才会返回ack，如果服务过多，一个出了异常整个系统都出了问题，有了消息中间件可以进行解耦，不受影响

![image-20210519172004613](消息中间件.assets/image-20210519172004613.png)

有了MQ之后，第一步执行后，将2、3要执行的写入到MQ中，如果写入MQ成功就直接返回ack，减少了用户的响应时间，注册信息在mq中2、3可以从中取数据，这样做到了异步相应

MQ的两个功能，存储数据、通知2、3，step1是provider，提交的数据叫做消息

消费时有两种方式，queue模式只要有人消费mq中就删除该消息，topic模式消息推送到所有连接到broker的节点

```java
public class Sender {

    public static void main(String[] args) throws Exception{

        // 1.获取连接工厂
        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(
                ActiveMQConnectionFactory.DEFAULT_USER,
                ActiveMQConnectionFactory.DEFAULT_PASSWORD,
                "tcp://localhost:61616"
        );

        // 2.获取一个向ActiveMQ的连接
        Connection connection = connectionFactory.createConnection();
        connection.start();
        // 3.获取session
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);//第一个参数是否需要事务

        // 4.找目的地，获取destination，消费端从这个目的地消费
        Queue queue = session.createQueue("user");

        // 5.向destination写入消息

        MessageProducer producer = session.createProducer(queue);//消息创建者
        /**
         * 写入消息的类型：
         * TextMessage 文本消息
         * MapMessage k/v
         * BytesMessage 字节流
         * StreamMessage java原始的数据流
         * ObjectMessage 序列化的java对象
         */

        for (int i = 0; i < 100 ; i++) {
            TextMessage textMessage = session.createTextMessage("hi:"+i);//创建消息
            producer.send(textMessage);

            Thread.sleep(1000);
        }
        // 6.关闭连接
        connection.close();
    }
}
```

```java
public class Receiver {

    public static void main(String[] args) throws Exception{

        // 1.获取连接工厂
        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(
                ActiveMQConnectionFactory.DEFAULT_USER,
                ActiveMQConnectionFactory.DEFAULT_PASSWORD,
                "tcp://localhost:61616"
        );

        // 2.获取一个向ActiveMQ的连接
        Connection connection = connectionFactory.createConnection();
        connection.start();
        // 3.获取session
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);//第一个参数是否需要事务，如果开启，send后不会写入到数据库，必须session.commit

        // 4.找目的地，获取destination，消费端从这个目的地消费
        Destination queue = session.createQueue("user");

        // 5.从destination获取消息
        MessageConsumer consumer = session.createConsumer(queue);

        while (true){
            TextMessage receive = (TextMessage) consumer.receive();

            System.out.println("message:"+receive.getText());
        }

    }
```

## 消息中间件应用场景

**异步通信**

有些业务不想也不需要立即处理消息（发邮件）。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。

**缓冲**

需要在不同时间点执行的任务，消息队列通过一个缓冲层来帮助任务最高效率的执行，该缓冲有助于控制和优化数据流经过系统的速度。以调节系统响应时间。

**解耦**

降低工程间的强依赖程度，针对异构系统进行适配。在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。通过消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，当应用发生变化时，可以独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。

**冗余**

有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。**消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。**许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。

**扩展性**

因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。便于分布式扩容。

**可恢复性**

系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。

**顺序保证**

在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。

**过载保护**

在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量无法提取预知；如果以为了能处理这类瞬间峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。

**数据流统计分析**

分布式系统产生的海量数据流，如：业务日志、监控数据、用户行为等，针对这些数据流进行实时或批量采集汇总，然后进行大数据分析是当前互联网的必备技术，通过消息队列完成此类数据收集是最好的选择。

## 不同消息中间件比较

| 特性MQ           | ActiveMQ   | RabbitMQ   | RocketMQ         | Kafka            |
| ---------------- | ---------- | ---------- | ---------------- | ---------------- |
| 生产者消费者模式 | 支持       | 支持       | 支持             | 支持             |
| 发布订阅模式     | 支持       | 支持       | 支持             | 支持             |
| 请求回应模式     | 支持       | 支持       | 不支持           | 不支持           |
| Api完备性        | 高         | 高         | 高               | 高               |
| 多语言支持       | 支持       | 支持       | java             | 支持             |
| 单机吞吐量       | 万级       | 万级       | 万级             | 十万级           |
| 消息延迟         | 无         | 微秒级     | 毫秒级           | 毫秒级           |
| 可用性           | 高（主从） | 高（主从） | 非常高（分布式） | 非常高（分布式） |
| 消息丢失         | 低         | 低         | 理论上不会丢失   | 理论上不会丢失   |
| 文档的完备性     | 高         | 高         | 高               | 高               |
| 提供快速入门     | 有         | 有         | 有               | 有               |
| 社区活跃度       | 高         | 高         | 有               | 高               |
| 商业支持         | 无         | 无         | 商业云           | 商业云           |

##  JMS中的一些角色

**Broker**

消息服务器，作为server提供消息核心服务

**provider**

生产者

消息生产者是由会话创建的一个对象，用于把消息发送到一个目的地。

**Consumer**

消费者

消息消费者是由会话创建的一个对象，它用于接收发送到目的地的消息。消息的消费可以采用以下两种方法之一：

- 同步消费。通过调用消费者的receive方法从目的地中显式提取消息。receive方法可以一直阻塞到消息到达。
- 异步消费。客户可以为消费者注册一个消息监听器，以定义在消息到达时所采取的动作。

**Queue**

队列存储，常用与点对点消息模型 

默认只能由唯一的一个消费者处理。一旦处理消息删除。 

**Topic**

主题存储，用于订阅/发布消息模型

主题中的消息，会发送给所有的消费者同时处理。只有在消息可以重复处 理的业务场景中可使用。

Queue/Topic都是 Destination 的子接口

**ConnectionFactory**

连接工厂，jms中用它创建连接

连接工厂是客户用来创建连接的对象，例如ActiveMQ提供的ActiveMQConnectionFactory。

**Connection**

JMS Connection封装了客户与JMS提供者之间的一个虚拟的连接。  

**Destination**

消息的目的地

目的地是客户用来指定它生产的消息的目标和它消费的消息的来源的对象。JMS1.0.2规范中定义了两种消息传递域：点对点（PTP）消息传递域和发布/订阅消息传递域。 点对点消息传递域的特点如下：

- 每个消息只能有一个消费者。
- 消息的生产者和消费者之间没有时间上的相关性。无论消费者在生产者发送消息的时候是否处于运行状态，它都可以提取消息。

发布/订阅消息传递域的特点如下：

-  每个消息可以有多个消费者。
-  生产者和消费者之间有时间上的相关性。
-  订阅一个主题的消费者只能消费自它订阅之后发布的消息。JMS规范允许客户创建持久订阅，这在一定程度上放松了时间上的相关性要求 。持久订阅允许消费者消费它在未处于激活状态时发送的消息。
   在点对点消息传递域中，目的地被成为队列（queue）；在发布/订阅消息传递域中，目的地被成为主题（topic）。

**Session**

JMS Session是生产和消费消息的一个单线程上下文。会话用于创建消息生产者（producer）、消息消费者（consumer）和消息（message）等。会话提供了一个事务性的上下文，在这个上下文中，一组发送和接收被组合到了一个原子操作中。

## 消费模型

### p2p

基于点对点的消息模型

消息生产者生产消息发送到 queue 中，然后消息消费者从 queue 中取出并且消费消息。 消息被消费以后，queue 中不再有存储，所以消息消费者不可能消费到已经被消费的消
息。
Queue 支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费、其它 的则不能消费此消息了。 当消费者不存在时，消息会一直保存，直到有消费消费

![image-20200110192535698](消息中间件.assets/image-20200110192535698.png)

### pub/sub

![image-20200110192613518](消息中间件.assets/image-20200110192613518.png)

基于订阅/发布的消息模型

消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消
息。
和点对点方式不同，发布到 topic 的消息会被**所有**订阅者消费。 当生产者发布消息，不管是否有消费者。都不会保存消息 **一定要先有消息的消费者，后有消息的生产者。**

### PTP 和 PUB/SUB 简单对比

| 1                 | Topic                                                        | Queue                                                        |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
|                   | Publish Subscribe messaging 发布 订阅消息                    | Point-to-Point 点对点                                        |
| 有无状态          | topic 数据默认不落地，是无状态的。                           | Queue 数据默认会在 mq 服 务器上以文件形式保存，比如 Active MQ 一 般 保 存 在 $AMQ_HOME\data\kahadb 下 面。也可以配置成 DB 存储。 |
| 完整性保障        | 并不保证 publisher 发布的每条数 据，Subscriber 都能接受到。  | Queue 保证每条数据都能 被 receiver 接收。消息不超时。        |
| 消息是否会丢失    | 一般来说 publisher 发布消息到某 一个 topic 时，只有正在监听该 topic 地址的 sub 能够接收到消息；如果没 有 sub 在监听，该 topic 就丢失了。 | Sender 发 送 消 息 到 目 标 Queue， receiver 可以异步接收这 个 Queue 上的消息。Queue 上的 消息如果暂时没有 receiver 来 取，也不会丢失。前提是消息不 超时。 |
| 消息发布接 收策略 | 一对多的消息发布接收策略，监 听同一个topic地址的多个sub都能收 到 publisher 发送的消息。Sub 接收完 通知 mq 服务器 | 一对一的消息发布接收策 略，一个 sender 发送的消息，只 能有一个 receiver 接收。 receiver 接收完后，通知 mq 服务器已接 收，mq 服务器对 queue 里的消 息采取删除或其他操作。 |
|                   |                                                              |                                                              |
|                   |                                                              |                                                              |



## Active MQ的安全机制

### web控制台安全

jetty-realm.properties

```properties
# username: password [,rolename ...]
admin: admin, admin
user: user, user
nyq: 123, user
```

用户名：密码，角色

注意: 配置需重启ActiveMQ才会生效。

### 消息安全机制

修改 activemq.xml

在123行     </broker> 节点中添加

```xml
	<plugins>
      <simpleAuthenticationPlugin>
          <users>
              <authenticationUser username="admin" password="admin" groups="admins,publishers,consumers"/>
              <authenticationUser username="publisher" password="publisher"  groups="publishers,consumers"/>
              <authenticationUser username="consumer" password="consumer" groups="consumers"/>
              <authenticationUser username="guest" password="guest"  groups="guests"/>
          </users>
      </simpleAuthenticationPlugin>
 </plugins>

```

```java
//修改后DEFAULT_USER，DEFAULT_PASSWORD需要替换成username、password的值
ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(
                ActiveMQConnectionFactory.DEFAULT_USER,
                ActiveMQConnectionFactory.DEFAULT_PASSWORD,
                "tcp://localhost:61616"
        );
```

## 持久化

保证mq宕机时数据可以恢复

### KahaDB存储

KahaDB是默认的持久化策略，所有消息顺序添加到一个日志文件中，同时另外有一个索引文件记录指向这些日志的存储地址，还有一个事务日志用于消息回复操作。是一个专门针对消息持久化的解决方案,它对典型的消息使用模式进行了优化。

在data/kahadb这个目录下，会生成四个文件，来完成消息持久化 
1.db.data 它是消息的索引文件，本质上是B-Tree（B树），使用B-Tree作为索引指向db-*.log里面存储的消息 
2.db.redo 用来进行消息恢复 *

3.db-.log 存储消息内容。新的数据以APPEND的方式追加到日志文件末尾。属于顺序写入，因此消息存储是比较 快的。默认是32M，达到阀值会自动递增 
4.lock文件 锁，写入当前获得kahadb读写权限的broker ，用于在集群环境下的竞争处理

```xml
<persistenceAdapter> 
    <!--directory:保存数据的目录;journalMaxFileLength:保存消息的文件大小 --> 		
    <kahaDBdirectory="${activemq.data}/kahadb"journalMaxFileLength="16mb"/> 
</persistenceAdapter>

```

特性：

1、日志形式存储消息；

2、消息索引以 B-Tree 结构存储，可以快速更新；

3、 完全支持 JMS 事务；

4、支持多种恢复机制kahadb 可以限制每个数据文件的大小。不代表总计数据容量。 

### AMQ 方式

只适用于 5.3 版本之前。 AMQ 也是一个文件型数据库，消息信息最终是存储在文件中。内存中也会有缓存数据。 

```xml
<persistenceAdapter> 
    <!--directory:保存数据的目录 ;maxFileLength:保存消息的文件大小 --> 
    <amqPersistenceAdapterdirectory="${activemq.data}/amq"maxFileLength="32mb"/> 
</persistenceAdapter>
```

 **性能高于 JDBC，写入消息时，会将消息写入日志文件，由于是顺序追加写，性能很高**

 为了提升性能，创建消息主键索引，并且提供缓存机制，进一步提升性能。

每个日志文件的 大小都是有限制的（默认 32m，可自行配置） 。 

当超过这个大小，系统会重新建立一个文件。

当所有的消息都消费完成，系统会删除这 个文件或者归档。 

主要的缺点是 AMQ Message 会为每一个 Destination 创建一个索引，如果使用了大量的 Queue，索引文件的大小会占用很多磁盘空间。 

而且由于索引巨大，一旦 Broker（ActiveMQ 应用实例）崩溃，重建索引的速度会非常 慢。 

虽然 AMQ 性能略高于 Kaha DB 方式，但是由于其**重建索引时间过长，而且索引文件 占用磁盘空间过大，所以已经不推荐使用**。

### JDBC存储 

使用JDBC持久化方式，数据库默认会创建3个表，每个表的作用如下： 
activemq_msgs：queue和topic的消息都存在这个表中 
activemq_acks：存储持久订阅的信息和最后一个持久订阅接收的消息ID 
activemq_lock：跟kahadb的lock文件类似，确保数据库在某一时刻只有一个broker在访问



ActiveMQ 将数据持久化到数据库中。 

不指定具体的数据库。 **可以使用任意的数据库** 中。 

本环节中使用 MySQL 数据库。 下述文件为 activemq.xml 配置文件部分内容。 

首先定义一个 mysql-ds 的 MySQL 数据源，然后在 persistenceAdapter 节点中配置 jdbcPersistenceAdapter 并且引用刚才定义的数据源。

dataSource 指定持久化数据库的 bean，createTablesOnStartup 是否在启动的时候创建数 据表，默认值是 true，这样每次启动都会去创建数据表了，一般是第一次启动的时候设置为 true，之后改成 false。 



activemq.xml的Beans标签中添加

```xml
<bean id="mysql-ds" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"> 
	<property name="driverClassName" value="com.mysql.jdbc.Driver"/> 
	<property name="url" value="jdbc:mysql://localhost/activemq?relaxAutoCommit=true&amp;characterEncoding=utf8"/> 
	<property name="username" value="activemq"/>
	<property name="password" value="activemq"/>
	<property name="maxActive" value="200"/>
	<property name="poolPreparedStatements" value="true"/> 
</bean>
```

**修改persistenceAdapter**

```xml
<persistenceAdapter>
    <!-- <kahaDB directory="${activemq.data}/kahadb"/> -->
    <jdbcPersistenceAdapter dataSource="#mysql-ds" createTablesOnStartup="true" /> //启动创建表
</persistenceAdapter>
```

依赖jar包

commons-dbcp commons-pool mysql-connector-java

**坑**

```
jvm 1    |  WARN | Could not get JDBC connection: Cannot create PoolableConnectionFactory (java.lang.ClassCastException: java.math.BigInteger cannot be cast to java.lang.Long)
jvm 1    | org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (java.lang.ClassCastException: java.math.BigInteger cannot be cast to java.lang.Long)
jvm 1    |      at org.apache.commons.dbcp.BasicDataSource.createPoolableConnectionFactory(BasicDataSource.java:1549)
```

connector 的版本太高

```
Unknown initial character set index '255' received from server. Initial client character set can be forced via the 'characterEncoding' property.
```

从错误的提示信息中发现字符集设置出现问题

```
 Failed to load: class path resource [activemq.xml], reason: Line 40 in XML document from class path resource [activemq.xml] is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: 40; columnNumber: 100; 对实体 "characterEncoding" 的引用必须以 ';' 分隔符结尾。
```

修改前

"jdbc:mysql://localhost/activemq?relaxAutoCommit=true&characterEncoding=utf8"

修改后 转义字符&amp；

"jdbc:mysql://localhost/activemq?relaxAutoCommit=true&amp;characterEncoding=utf8"



**表字段解释**

**activemq_acks**：用于存储订阅关系。如果是持久化Topic，订阅者和服务器的订阅关系在这个表保存。
主要的数据库字段如下：

```properties
container：消息的destination 
sub_dest：如果是使用static集群，这个字段会有集群其他系统的信息 
client_id：每个订阅者都必须有一个唯一的客户端id用以区分 
sub_name：订阅者名称 
selector：选择器，可以选择只消费满足条件的消息。条件可以用自定义属性实现，可支持多属性and和or操作 
last_acked_id：记录消费过的消息的id。
```

2：**activemq_lock**：在集群环境中才有用，只有一个Broker可以获得消息，称为Master Broker，其他的只能作为备份等待Master Broker不可用，才可能成为下一个Master Broker。这个表用于记录哪个Broker是当前的Master Broker。

3：**activemq_msgs**：用于存储消息，Queue和Topic都存储在这个表中。
主要的数据库字段如下：

```
id：自增的数据库主键 
container：消息的destination 
msgid_prod：消息发送者客户端的主键 
msg_seq：是发送消息的顺序，msgid_prod+msg_seq可以组成jms的messageid 
expiration：消息的过期时间，存储的是从1970-01-01到现在的毫秒数 
msg：消息本体的java序列化对象的二进制数据 
priority：优先级，从0-9，数值越大优先级越高 
xid:用于存储订阅关系。如果是持久化topic，订阅者和服务器的订阅关系在这个表保存。
```

![image-20210604153047160](消息中间件.assets/image-20210604153047160.png)

### LevelDB存储 

LevelDB持久化性能高于KahaDB，虽然目前默认的持久化方式仍然是KahaDB。并且，在ActiveMQ 5.9版本提供 了基于LevelDB和Zookeeper的数据复制方式，用于Master-slave方式的首选数据复制方案。 但是在ActiveMQ官网对LevelDB的表述：LevelDB官方建议使用以及不再支持，推荐使用的是KahaDB 


### Memory 消息存储

顾名思义，基于内存的消息存储，就是消息存储在内存中。persistent=”false”,表示不设置持 久化存储，直接存储到内存中 
在broker标签处设置。

### JDBC Message store with ActiveMQ Journal 

这种方式克服了JDBC Store的不足，JDBC存储每次消息过来，都需要去写库和读库。 ActiveMQ Journal，使用延迟存储数据到数据库，当消息来到时先缓存到文件中，延迟后才写到数据库中。

当消费者的消费速度能够及时跟上生产者消息的生产速度时，journal文件能够大大减少需要写入到DB中的消息。 举个例子，生产者生产了1000条消息，这1000条消息会保存到journal文件，如果消费者的消费速度很快的情况 下，在journal文件还没有同步到DB之前，消费者已经消费了90%的以上的消息，那么这个时候只需要同步剩余的 10%的消息到DB。 如果消费者的消费速度很慢，这个时候journal文件可以使消息以批量方式写到DB。 

## 协议

完整支持的协议

http://activemq.apache.org/configuring-version-5-transports.html

ActiveMQ支持的client-broker通讯协议有：TCP、NIO、UDP、SSL、Http(s)、VM。

### Transmission Control Protocol (TCP) 

1：**这是默认的Broker配置，TCP的Client监听端口是61616。**
2：在网络传输数据前，必须要序列化数据，消息是通过一个叫wire protocol的来序列化成字节流。默认情况下，ActiveMQ把wire protocol叫做OpenWire，它的目的是促使网络上的效率和数据快速交互。
3：TCP连接的URI形式：tcp://hostname:port?key=value&key=value，加粗部分是必须的
4：TCP传输的优点：
(1)TCP协议传输可靠性高，稳定性强
(2)高效性：字节流方式传递，效率很高
(3)有效性、可用性：应用广泛，支持任何平台

```xml
<transportConnector name="openwire" uri="tcp://0.0.0.0:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"/>
```

### New I/O API Protocol（NIO） 

1：NIO协议和TCP协议类似，但NIO更侧重于底层的访问操作。它允许开发人员对同一资源可有更多的client调用和服务端有更多的负载。 
2：适合使用NIO协议的场景：
(1)可能有大量的Client去链接到Broker上一般情况下，大量的Client去链接Broker是被操作系统的线程数所限制的。因此，NIO的实现比TCP需要更少的线程去运行，所以建议使用NIO协议
(2)可能对于Broker有一个很迟钝的网络传输NIO比TCP提供更好的性能
3：NIO连接的URI形式：nio://hostname:port?key=value
4：Transport Connector配置示例： 

```xml
<transportConnectors>
　　<transportConnector
　　　　name="tcp"
　　　　uri="tcp://localhost:61616?trace=true" />
　　<transportConnector
　　　　name="nio"
　　　　uri="nio://localhost:61618?trace=true" />
</transportConnectors>
```


上面的配置，示范了一个TCP协议监听61616端口，一个NIO协议监听61618端口 

### User Datagram Protocol（UDP)

1：UDP和TCP的区别
(1)TCP是一个原始流的传递协议，意味着数据包是有保证的，换句话说，数据包是不会被复制和丢失的。UDP，另一方面，它是不会保证数据包的传递的
(2)TCP也是一个稳定可靠的数据包传递协议，意味着数据在传递的过程中不会被丢失。这样确保了在发送和接收之间能够可靠的传递。相反，UDP仅仅是一个链接协议，所以它没有可靠性之说
2：从上面可以得出：TCP是被用在稳定可靠的场景中使用的；UDP通常用在快速数据传递和不怕数据丢失的场景中，还有ActiveMQ通过防火墙时，只能用UDP
3：UDP连接的URI形式：udp://hostname:port?key=value
4：Transport Connector配置示例： 

```xml
<transportConnectors>
    <transportConnector
        name="udp"
        uri="udp://localhost:61618?trace=true" />
</transportConnectors>
```

### Secure Sockets Layer Protocol (SSL) 

1：连接的URI形式：ssl://hostname:port?key=value
2：Transport Connector配置示例： 

```xml
<transportConnectors>
    <transportConnector name="ssl" uri="ssl://localhost:61617?trace=true"/>
</transportConnectors>
```

### Hypertext Transfer Protocol (HTTP/HTTPS) 

1：像web和email等服务需要通过防火墙来访问的，Http可以使用这种场合
2：连接的URI形式：http://hostname:port?key=value或者https://hostname:port?key=value
3：Transport Connector配置示例：

```xml
<transportConnectors>
    <transportConnector name="http" uri="http://localhost:8080?trace=true" />
</transportConnectors>
```



### VM Protocol（VM） 

1、VM transport允许在VM内部通信，从而避免了网络传输的开销。这时候采用的连 接不是socket连接，而是直接的方法调用。 

2、第一个创建VM连接的客户会启动一个embed VM broker，接下来所有使用相同的 broker name的VM连接都会使用这个broker。当这个broker上所有的连接都关闭 的时候，这个broker也会自动关闭。 

3、连接的URI形式：vm://brokerName?key=value 

4、Java中嵌入的方式： vm:broker:(tcp://localhost:6000)?brokerName=embeddedbroker&persistent=false ， 定义了一个嵌入的broker名称为embededbroker以及配置了一个 tcptransprotconnector在监听端口6000上 

5、使用一个加载一个配置文件来启动broker vm://localhost?brokerConfig=xbean:activemq.xml



## 消息可靠性机制

### 确认 JMS消息

只有在被确认之后，才认为已经被成功地消费了。

消息的成功消费通常包含三个阶段：客户接收消息、客户处理消息和消息被确认。 

在事务性会话中，当一个事务被提交的时候，确认自动发生。

在非事务性会话中，消息何时被确认取决于创建会话时的应答模式（acknowledgement mode）。该参数有以下三个可选值：

- Session.AUTO_ACKNOWLEDGE。当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。
- Session.CLIENT_ACKNOWLEDGE。客户通过消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行：确认一个被消费的消息将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。（手动确认消息，如果不确认，消息可能被别的客户端消费 ）
- Session.DUPS_ACKNOWLEDGE。该选择只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS Provider必须把消息头的JMSRedelivered字段设置为true。

### 持久性

JMS 支持以下两种消息提交模式：

- PERSISTENT。指示JMS Provider持久保存消息，以保证消息不会因为JMS Provider的失败而丢失。
- NON_PERSISTENT。不要求JMS Provider持久保存消息。

### 优先级

可以使用消息优先级来指示JMS Provider首先提交紧急的消息。优先级分10个级别，从0（最低）到9（最高）。如果不指定优先级，默认级别是4。需要注意的是，JMS Provider并不一定保证按照优先级的顺序提交消息。

### 消息过期

可以设置消息在一定时间后过期，默认是永不过期。

### 临时目的地

可以通过会话上的createTemporaryQueue方法和createTemporaryTopic方法来创建临时目的地。它们的存在时间只限于创建它们的连接所保持的时间。只有创建该临时目的地的连接上的消息消费者才能够从临时目的地中提取消息。

### 持久订阅

首先消息生产者必须使用PERSISTENT提交消息。客户可以通过会话上的createDurableSubscriber方法来创建一个持久订阅，该方法的第一个参数必须是一个topic，第二个参数是订阅的名称。 JMS Provider会存储发布到持久订阅对应的topic上的消息。如果最初创建持久订阅的客户或者任何其它客户使用相同的连接工厂和连接的客户ID、相同的主题和相同的订阅名再次调用会话上的createDurableSubscriber方法，那么该持久订阅就会被激活。JMS Provider会象客户发送客户处于非激活状态时所发布的消息。 持久订阅在某个时刻只能有一个激活的订阅者。持久订阅在创建之后会一直保留，直到应用程序调用会话上的unsubscribe方法。

### 本地事务

在一个JMS客户端，可以使用本地事务来组合消息的发送和接收。JMS Session接口提供了commit和rollback方法。

事务提交意味着生产的所有消息被发送，消费的所有消息被确认；

事务回滚意味着生产的所有消息被销毁，消费的所有消息被恢复并重新提交，除非它们已经过期。 事务性的会话总是牵涉到事务处理中，commit或rollback方法一旦被调用，一个事务就结束了，而另一个事务被开始。关闭事务性会话将回滚其中的事务。

需要注意的是，如果使用请求/回复机制，即发送一个消息，同时希望在同一个事务中等待接收该消息的回复，那么程序将被挂起，因为知道事务提交，发送操作才会真正执行。 需要注意的还有一个，消息的生产和消费不能包含在同一个事务中。

# Active MQ 02



## 常用API

### 事务

```java
session.commit();
session.rollback();
```

用来提交/回滚事务

###  Purge

清理消息

### 签收模式

签收代表接收端的session已收到消息的一次确认，反馈给broker

ActiveMQ支持自动签收与手动签收

#### Session.AUTO_ACKNOWLEDGE

当客户端从receiver或onMessage成功返回时，Session自动签收客户端的这条消息的收条。

 

#### Session.CLIENT_ACKNOWLEDGE

客户端通过调用消息(Message)的acknowledge方法签收消息。在这种情况下，签收发生在Session层面：签收一个已经消费的消息会自动地签收这个Session所有已消费的收条。

####  Session.DUPS_OK_ACKNOWLEDGE

Session不必确保对传送消息的签收，这个模式可能会引起消息的重复，但是降低了Session的开销，所以只有客户端能容忍重复的消息，才可使用。



### 持久化

默认持久化是开启的

```
producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT)
```

### 优先级

可以打乱消费顺序

```
producer.setPriority
```

配置文件需要指定使用优先级的目的地

```
<policyEntry queue="queue1" prioritizedMessages="true" />
```

### 消息超时/过期

```
producer.setTimeToLive
```

设置了消息超时的消息，消费端在超时后无法在消费到此消息。



给消息设置一个超时时间 -> 死信队列 -> 拿出来 -> 重发



#### 死信

此类消息会进入到`ActiveMQ.DLQ`队列且不会自动清除，称为死信

此处有消息堆积的风险

#### 修改死信队列名称

```xml
			  <policyEntry queue="f" prioritizedMessages="true" >
				<deadLetterStrategy> 

					<individualDeadLetterStrategy   queuePrefix="DLxxQ." useQueueForQueueMessages="true" /> 

				</deadLetterStrategy> 
			  </policyEntry>
```

useQueueForQueueMessages: 设置使用队列保存死信，还可以设置useQueueForTopicMessages，使用Topic来保存死信 

#### 让非持久化的消息也进入死信队列

```
			<individualDeadLetterStrategy   queuePrefix="DLxxQ." useQueueForQueueMessages="true"  processNonPersistent="true" /> 
```

processNonPersistent="true"

#### 过期消息不进死信队列

```
<individualDeadLetterStrategy   processExpired="false"  /> 
```

### 独占消费者

```
	Queue queue = session.createQueue("xxoo?consumer.exclusive=true");
```

还可以设置优先级

```
Queue queue = session.createQueue("xxoo?consumer.exclusive=true&consumer.priority=10");
```



## 消息类型

### object

#### 发送端

```java
		Girl girl = new Girl("qiqi",25,398.0);				Message message = session.createObjectMessage(girl);
```



#### 接受端

```java
		if(message instanceof ActiveMQObjectMessage) {						Girl girl = (Girl)((ActiveMQObjectMessage)message).getObject();						System.out.println(girl);			System.out.println(girl.getName());		}
```



**如果遇到此类报错**

```
Exception in thread "main" javax.jms.JMSException: Failed to build body from content. Serializable class not available to broker. Reason: java.lang.ClassNotFoundException: Forbidden class com.mashibing.mq.Girl! This class is not trusted to be serialized as ObjectMessage payload. Please take a look at http://activemq.apache.org/objectmessage.html for more information on how to configure trusted classes.	at org.apache.activemq.util.JMSExceptionSupport.create(JMSExceptionSupport.java:36)	at org.apache.activemq.command.ActiveMQObjectMessage.getObject(ActiveMQObjectMessage.java:213)	at com.mashibing.mq.Receiver.main(Receiver.java:65)Caused by: java.lang.ClassNotFoundException: Forbidden class com.mashibing.mq.Girl! This class is not trusted to be serialized as ObjectMessage payload. Please take a look at http://activemq.apache.org/objectmessage.html for more information on how to configure trusted classes.	at org.apache.activemq.util.ClassLoadingAwareObjectInputStream.checkSecurity(ClassLoadingAwareObjectInputStream.java:112)	at org.apache.activemq.util.ClassLoadingAwareObjectInputStream.resolveClass(ClassLoadingAwareObjectInputStream.java:57)	at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1868)	at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751)	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042)	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431)	at org.apache.activemq.command.ActiveMQObjectMessage.getObject(ActiveMQObjectMessage.java:211)	... 1 more
```

**需要添加信任**

```java
		connectionFactory.setTrustedPackages(				new ArrayList<String>(Arrays.asList(new String[]{Girl.class.getPackage().getName()}									
        )						
        )						
        );
```

### bytesMessage

#### 发送端

```
		BytesMessage bytesMessage = session.createBytesMessage();        bytesMessage.writeBytes("str".getBytes());        bytesMessage.writeUTF("哈哈");
```

#### 接受端

```java
		if(message instanceof BytesMessage) {			BytesMessage bm = (BytesMessage)message;						 byte[] b = new byte[1024];             int len = -1;             while ((len = bm.readBytes(b)) != -1) {                 System.out.println(new String(b, 0, len));             }		}
```





还可以使用ActiveMQ给提供的便捷方法,但要注意读取和写入的顺序

```
bm.readBoolean()bm.readUTF()
```



#### 写入文件

```java
FileOutputStream out = null;           
try {                       
    out = new FileOutputStream("d:/aa.txt");          
} catch (FileNotFoundException e2) {           
    e2.printStackTrace();               
}                  
byte[] by = new byte[1024];            
int len = 0 ;                  
try {                       
    while((len = bm.readBytes(by))!= -1){     
        out.write(by,0,len);                   
    }                  
} catch (Exception e1) {  e1.printStackTrace();          
                       }
```

### MapMessage

#### 发送端

```java
MapMessage mapMessage = session.createMapMessage();      
mapMessage.setString("name","lucy");      
mapMessage.setBoolean("yihun",false);		
mapMessage.setInt("age", 17);				
producer.send(mapMessage);
```

#### 接收端

```java
Message message = consumer.receive();
MapMessage mes = (MapMessage) message;				
System.out.println(mes);		
System.out.println(mes.getString("name"));
```

## 消息发送原理

### 同步与异步

|          | 开启事务 | 关闭事务 |
| -------- | -------- | -------- |
| 持久化   | 异步     | 同步     |
| 非持久化 | 异步     | 异步     |
|          |          |          |
|          |          |          |

我们可以通过以下几种方式来设置异步发送：

```java
ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("admin","admin","tcp://localhost:61616");	 
// 2.获取一个向ActiveMQ的连接		
connectionFactory.setUseAsyncSend(true);	
ActiveMQConnection connection = (ActiveMQConnection)connectionFactory.createConnection();		connection.setUseAsyncSend(true);
```

### 消息堆积

producer每发送一个消息，统计一下发送的字节数，当字节数达到ProducerWindowSize值时，需要等待broker的确认，才能继续发送。

brokerUrl中设置: `tcp://localhost:61616?jms.producerWindowSize=1048576`

destinationUri中设置: `myQueue?producer.windowSize=1048576`

### 延迟消息投递

首先在配置文件中开启延迟和调度

**schedulerSupport="true"**

```
    <broker xmlns="http://activemq.apache.org/schema/core" brokerName="localhost" dataDirectory="${activemq.data}" schedulerSupport="true">
```

### 延迟发送

```
message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, 10*1000);
```

### 带间隔的重复发送

```java
long delay = 10 * 1000;		
long period = 2 * 1000;		
int repeat = 9;		
message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);		message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, period);		message.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, repeat);		
createProducer.send(message);
```

### Cron表达式定时发送

Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式： 

*Seconds Minutes Hours DayofMonth Month DayofWeek Year或* 

Seconds Minutes Hours DayofMonth Month DayofWeek

每一个域可出现的字符如下： 

Seconds:可出现", - * /"四个字符，有效范围为0-59的整数 

Minutes:可出现", - * /"四个字符，有效范围为0-59的整数 

Hours:可出现", - * /"四个字符，有效范围为0-23的整数 

DayofMonth:可出现", - * / ? L W C"八个字符，有效范围为0-31的整数 

Month:可出现", - * /"四个字符，有效范围为1-12的整数或JAN-DEc 

DayofWeek:可出现", - * / ? L C #"四个字符，有效范围为1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一， 依次类推 

Year:可出现", - * /"四个字符，有效范围为1970-2099年

每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是： 

(1)*：表示匹配该域的任意值，假如在Minutes域使用*, 即表示每分钟都会触发事件。

(2)?:只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和 DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*，如果使用*表示不管星期几都会触发，实际上并不是这样。 

(3)-:表示范围，例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 

(4)/：表示起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. 

(5),:表示列出枚举值值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 

(6)L:表示最后，只能出现在DayofWeek和DayofMonth域，如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 

(7)W: 表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一 到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 

(8)LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 

(9)#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。

举几个例子: 

0 0 2 1 * ? * 表示在每月的1日的凌晨2点调度任务 

0 15 10 ? * MON-FRI 表示周一到周五每天上午10：15执行作业 

0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作

一个cron表达式有至少6个（也可能7个）有空格分隔的时间元素。 

按顺序依次为 

秒（0~59） 

分钟（0~59） 

小时（0~23） 

天（月）（0~31，但是你需要考虑你月的天数） 

月（0~11） 

天（星期）（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT） 

年份（1970－2099）

其中每个元素可以是一个值(如6),一个连续区间(9-12),一个间隔时间(8-18/4)(/表示每隔4小时),一个列表(1,3,5),通配符。由于"月份中的日期"和"星期中的日期"这两个元素互斥的,必须要对其中一个设置?

0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 

0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 

0 0 12 ? * WED 表示每个星期三中午12点 

"0 0 12 * * ?" 每天中午12点触发 

"0 15 10 ? * *" 每天上午10:15触发 

"0 15 10 * * ?" 每天上午10:15触发 

"0 15 10 * * ? *" 每天上午10:15触发 

"0 15 10 * * ? 2005" 2005年的每天上午10:15触发 

"0 * 14 * * ?" 在每天下午2点到下午2:59期间的每1分钟触发 

"0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发 

"0 0/5 14,18 * * ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 

"0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发 

"0 10,44 14 ? 3 WED" 每年三月的星期三的下午2:10和2:44触发 

"0 15 10 ? * MON-FRI" 周一至周五的上午10:15触发 

"0 15 10 15 * ?" 每月15日上午10:15触发 

"0 15 10 L * ?" 每月最后一日的上午10:15触发 

"0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发 

"0 15 10 ? * 6L 2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发 

"0 15 10 ? * 6#3" 每月的第三个星期五上午10:15触发

## 监听器

可以使用监听器来处理消息接收

```java
consumer.setMessageListener(new MyListener());
```

需要实现接口MessageListener

```java
public class MyListener implements MessageListener {	
	public void onMessage(Message message) {		
	// TODO Auto-generated method stub		
	TextMessage textMessage = (TextMessage)message;		
	try {			
		System.out.println("xxoo" + textMessage.getText());		
		} catch (JMSException e) {			
		// TODO Auto-generated catch block			
		e.printStackTrace();		
		}	
		
	}		
}
```

当收到消息后会调起onMessage方法

## 消息过滤

### 消息发送

```java
MapMessage msg1 = session.createMapMessage();		
msg1.setString("name", "qiqi");		
msg1.setString("age", "18");				
msg1.setStringProperty("name", "qiqi");		
msg1.setIntProperty("age", 18);	

MapMessage msg2 = session.createMapMessage();		
msg2.setString("name", "lucy");		
msg2.setString("age", "18");		
msg2.setStringProperty("name", "lucy");		
msg2.setIntProperty("age", 18);	

MapMessage msg3 = session.createMapMessage();		
msg3.setString("name", "qianqian");		
msg3.setString("age", "17");		
msg3.setStringProperty("name", "qianqian");		
msg3.setIntProperty("age", 17);
```

### 消息接收

```java
String selector1 = "age > 17";		
String selector2 = "name = 'lucy'";		
MessageConsumer consumer = session.createConsumer(queue,selector2);
```

# Active MQ 03

## 整合SpringBoot

### 配置文件

#### POM

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.2.3.BUILD-SNAPSHOT</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.mashibing.arika</groupId>
	<artifactId>mq</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>mq</name>
	<description>Demo project for Spring Boot</description>

	<properties>
		<java.version>1.8</java.version>
	</properties>

	<dependencies>
		

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
			<exclusions>
				<exclusion>
					<groupId>org.junit.vintage</groupId>
					<artifactId>junit-vintage-engine</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-activemq</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		
		
		<dependency>
		    <groupId>org.messaginghub</groupId>
		    <artifactId>pooled-jms</artifactId>
		</dependency>
				
		<dependency>
	            <groupId>org.apache.commons</groupId>
	            <artifactId>commons-pool2</artifactId>
	        </dependency>
		</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

	<repositories>
		<repository>
			<id>spring-milestones</id>
			<name>Spring Milestones</name>
			<url>https://repo.spring.io/milestone</url>
		</repository>
		<repository>
			<id>spring-snapshots</id>
			<name>Spring Snapshots</name>
			<url>https://repo.spring.io/snapshot</url>
			<snapshots>
				<enabled>true</enabled>
			</snapshots>
		</repository>
	</repositories>
	<pluginRepositories>
		<pluginRepository>
			<id>spring-milestones</id>
			<name>Spring Milestones</name>
			<url>https://repo.spring.io/milestone</url>
		</pluginRepository>
		<pluginRepository>
			<id>spring-snapshots</id>
			<name>Spring Snapshots</name>
			<url>https://repo.spring.io/snapshot</url>
			<snapshots>
				<enabled>true</enabled>
			</snapshots>
		</pluginRepository>
	</pluginRepositories>

</project>

```

#### yml

```yaml
server:
  port: 80
  
spring:
  activemq:
    broker-url: tcp://localhost:61616
    user: admin
    password: admin
    
    pool:
      enabled: true
      #连接池最大连接数
      max-connections: 5
      #空闲的连接过期时间，默认为30秒
      idle-timeout: 0
    packages:
      trust-all: true
  jms:
    pub-sub-domain: true
```

#### Config类

用于生产ConnectionFactory

```java
package com.mashibing.arika;

import javax.jms.ConnectionFactory;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jms.annotation.EnableJms;
import org.springframework.jms.config.DefaultJmsListenerContainerFactory;
import org.springframework.jms.config.JmsListenerContainerFactory;

@Configuration
@EnableJms
public class ActiveMqConfig {

	 @Bean
	    public JmsListenerContainerFactory<?> jmsListenerContainerTopic(ConnectionFactory activeMQConnectionFactory) {
	        DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();
	        bean.setPubSubDomain(true);
	        bean.setConnectionFactory(activeMQConnectionFactory);
	        return bean;
	    }
	    // queue模式的ListenerContainer
	    @Bean
	    public JmsListenerContainerFactory<?> jmsListenerContainerQueue(ConnectionFactory activeMQConnectionFactory) {
	        DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();
	        bean.setConnectionFactory(activeMQConnectionFactory);
	        return bean;
	    }
}

```



#### 收

```java
	@JmsListener(destination = "user",containerFactory = "jmsListenerContainerQueue")
	   public void receiveStringQueue(String msg) {
        System.out.println("接收到消息...." + msg);
    }
	
	@JmsListener(destination = "ooo",containerFactory = "jmsListenerContainerTopic")
	   public void receiveStringTopic(String msg) {
     System.out.println("接收到消息...." + msg);
 }
```

#### 发

```java
package com.mashibing.arika;

import java.util.ArrayList;

import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageProducer;
import javax.jms.Queue;
import javax.jms.Session;
import javax.jms.TextMessage;

import org.apache.activemq.command.ActiveMQQueue;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jms.core.JmsMessagingTemplate;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.MessageCreator;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

@Service
public class MqProducerService {

	@Autowired
	private JmsMessagingTemplate jmsMessagingTemplate;
	
	public void sendStringQueue(String destination, String msg) {
		System.out.println("send...");
		ActiveMQQueue queue = new ActiveMQQueue(destination);
		jmsMessagingTemplate.afterPropertiesSet();
		
		ConnectionFactory factory = jmsMessagingTemplate.getConnectionFactory();
		
		try {
			Connection connection = factory.createConnection();
			connection.start();
			
			Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
			Queue queue2 = session.createQueue(destination);
			
			MessageProducer producer = session.createProducer(queue2);
			
			TextMessage message = session.createTextMessage("hahaha");
			
			
			producer.send(message);
		} catch (JMSException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		jmsMessagingTemplate.convertAndSend(queue, msg);
	}
	public void sendStringQueueList(String destination, String msg) {
		System.out.println("xxooq");
		ArrayList<String> list = new ArrayList<>();
		list.add("1");
		list.add("2");
		jmsMessagingTemplate.convertAndSend(new ActiveMQQueue(destination), list);
	}
}

```

